using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.Linq;
using System.Text;
using Domain.Service.Generator.Extensions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Domain.Service.Generator;

// ReSharper disable once ClassNeverInstantiated.Global
public sealed class PaginationGenerator
{
    [Generator]
    public class ServiceForPaginationRequestGenerator : IIncrementalGenerator
    {
        private class Target(INamedTypeSymbol @class, ITypeSymbol entity)
        {
            public INamedTypeSymbol Class { get; } = @class;
            public ITypeSymbol Entity { get; } = entity;
        }

        private const string AttributeFqdn = "Domain.Service.PaginationHandlerForAttribute`1";

        private const string AttributeSourceCode =
            """
            // <auto-generated/>
            using System;
            namespace Domain.Service;

                [AttributeUsage(AttributeTargets.Class)]
                [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
                internal class PaginationHandlerForAttribute<TEntity> : Attribute
                    where TEntity : class {}
            """;

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(ctx =>
            {
                ctx.AddEmbeddedAttributeDefinition();
                ctx.AddSource("PaginationHandlerFor.g.cs", AttributeSourceCode);
            });

            IncrementalValueProvider<ImmutableArray<Target>> classProvider =
                context.SyntaxProvider.ForAttributeWithMetadataName(
                        AttributeFqdn,
                        predicate: static (node, _) => node is ClassDeclarationSyntax,
                        transform: static (ctx, _) => new Target(
                            (INamedTypeSymbol)ctx.TargetSymbol,
                            ctx.Attributes[0].AttributeClass!.TypeArguments[0]))
                    .Collect();

            context.RegisterImplementationSourceOutput(classProvider, (spc, targets) =>
            {
                foreach (var target in targets)
                {
                    // ReSharper disable once InconsistentNaming
                    var _entityMembers = target.Entity
                        .GetMembers()
                        .OfType<IPropertySymbol>()
                        .Where(member => member.DeclaredAccessibility == Accessibility.Public)
                        .ToArray();
                    // ReSharper disable once InconsistentNaming
                    var _entityInterfacesMembers = target.Entity.AllInterfaces
                        .SelectMany(x => x.GetMembers())
                        .OfType<IPropertySymbol>()
                        .Where(member => member.DeclaredAccessibility == Accessibility.Public)
                        .ToArray();

                    var @namespace = target.Class.ContainingNamespace.ToDisplayString();
                    var @className = target.Class.Name;
                    var @entityFullName = target.Entity.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var @entityProperties = Enumerable.GroupBy([.._entityMembers, .._entityInterfacesMembers], x => x.Name)
                            .Select(x => x.First())
                            .ToArray();

#pragma warning disable format // @formatter:off
                    var source =
$$"""
// <auto-generated/>
#nullable enable

using System;
using Domain.Service.Contract.Dto.PaginationDto;
using Microsoft.EntityFrameworkCore;
using System.ComponentModel;
using System.Linq.Expressions;

using t1 = {{@entityFullName}};

namespace {{@namespace}};

public static class QueryableExtensions
{
    public static IQueryable<t1> ProcessPaginationRequest(this IQueryable<t1> query, PaginationServiceRequest request, out Func<CancellationToken, Task<int>> countAsync)
    {
        return query
            .ApplyFiltering(request.FilterServiceRequests, out countAsync)
            .ApplySorting(request.SortServiceRequests)
            .ApplyPagination(request.PageNumber, request.PageSize);
    }

    private static IQueryable<t1> ApplyPagination(this IQueryable<t1> query, int pageNumber, int pageSize) => query.Skip((pageNumber - 1) * pageSize).Take(pageSize);

    private static IQueryable<t1> ApplySorting(this IQueryable<t1> query, IEnumerable<SortServiceRequest> requests)
    {
        bool hasFirstSort = false;

        foreach (var request in requests)
        {
            if (!hasFirstSort)
            {
                switch (request.PropertyName)
                {
                    {{string.Join("\n", @entityProperties.Select<IPropertySymbol, string>(property => {
                        var propertySwitchSelector = SwitchCaseSelectorForEntityProperty(property);

                        return $"""
                        {propertySwitchSelector}
                            query = !request.IsDescending
                                ? query.OrderBy(x => x.{property.Name})
                                : query.OrderByDescending(x => x.{property.Name});
                                break;
                        """;
                    }))}}
                    default:
                        throw new ArgumentOutOfRangeException(nameof(requests));
                }

                hasFirstSort = true;
            }
            else
            {
                switch (request.PropertyName)
                {
                    {{string.Join("\n", @entityProperties.Select<IPropertySymbol, string>(property => {
                        var propertySwitchSelector = SwitchCaseSelectorForEntityProperty(property);

                        return $"""
                        {propertySwitchSelector}
                            query = !request.IsDescending
                                ? (query as IOrderedQueryable<t1>)!.ThenBy(x => x.{property.Name})
                                : (query as IOrderedQueryable<t1>)!.ThenByDescending(x => x.{property.Name});
                                break;
                        """;
                    }))}}
                }
            }
        }

        return query;
    }

    private static IQueryable<t1> ApplyFiltering(this IQueryable<t1> query, IEnumerable<FilterServiceRequest> requests, out Func<CancellationToken, Task<int>> countAsync)
    {
        var param = Expression.Parameter(typeof(t1), "x");
        Expression? combined = null;

        foreach (var request in requests)
        {
            var filterExpression = BuildFilterExpression(request, param);

            combined = combined is null
                ? filterExpression
                : CombineExpressions(combined, filterExpression, request.FilterLogic);
        }

        query = combined is null
            ? query
            : query.Where(Expression.Lambda<Func<t1, bool>>(combined, param));
            
        countAsync = query.CountAsync;

        return query;

        Expression BuildFilterExpression(FilterServiceRequest request, ParameterExpression param)
        {
            Expression comparision = null!;

            switch (request.PropertyName)
            {
                {{string.Join("\n", @entityProperties.Select<IPropertySymbol, string>(property => {
                    var propertySwitchSelector = SwitchCaseSelectorForEntityProperty(property);
                    var propertyValueParserAndComparer = BuildValueParserAndComparerForProperty(property);

                    if (string.IsNullOrWhiteSpace(propertyValueParserAndComparer)) return string.Empty;

                    return $$"""
                    {{propertySwitchSelector}} {
                        {{propertyValueParserAndComparer}}
                        break;
                    }
                    """;
                }))}}
                default: throw new NotImplementedException($"No filter available for {request.PropertyName}");
            }

            if (!request.Filters.Any()) return comparision;

            Expression? nestedCombined = null;

            foreach (var subFilter in request.Filters)
            {
                var subExpression = BuildFilterExpression(subFilter, param);

                nestedCombined = nestedCombined is null
                    ? subExpression
                    : CombineExpressions(nestedCombined, subExpression, subFilter.FilterLogic);
            }

            if (nestedCombined is not null)
            {
                comparision = CombineExpressions(comparision, nestedCombined, request.Filters.First().FilterLogic);
            }

            return comparision;
        }
    }

    private static Expression CombineExpressions(Expression left, Expression right, FilterServiceRequest.Logic logic) =>
        logic switch
        {
            FilterServiceRequest.Logic.And => Expression.AndAlso(left, right),
            FilterServiceRequest.Logic.Or => Expression.OrElse(left, right),
            _ => throw new ArgumentOutOfRangeException(),
        };
}
""";
#pragma warning restore format // @formatter:on

                    spc.AddSource($"{className}.paginationHandler.g.cs", source);
                }
            });
        }

        /// <summary>
        /// Return a switch case selector with all possible formats for a property symbol
        /// </summary>
        /// <example>
        /// <code>
        /// [...]
        /// case "string_format":
        /// case "StringFormat":
        /// case "stringFormat":
        /// [...]
        /// </code>
        /// </example>
        /// <param name="propertySymbol"></param>
        /// <returns></returns>
        private string SwitchCaseSelectorForEntityProperty(IPropertySymbol propertySymbol)
        {
            return string.Join("\n", GetAllFormatForString(propertySymbol.Name).Distinct().Select(x => $"case \"{x}\":"));
        }

        /// <summary>
        /// Return all possible format for a string
        /// </summary>
        /// <param name="input">string to format</param>
        /// <returns></returns>
        private static IEnumerable<string> GetAllFormatForString(string input)
        {
            yield return input;
            yield return input.ToCamelCase();
            yield return input.ToPascalCase();
            yield return input.ToLowerSnakeCase();
            yield return input.ToUnderscoreCamelCase();
            yield return CultureInfo.InvariantCulture.TextInfo.ToTitleCase(input);
            yield return CultureInfo.InvariantCulture.TextInfo.ToLower(input);
            yield return CultureInfo.InvariantCulture.TextInfo.ToUpper(input);
        }

        private static string BuildValueParserAndComparerForProperty(
            IPropertySymbol propertySymbol)
        {
            var isNullable = propertySymbol.Type.Name == nameof(Nullable);
            var typeName = isNullable
                ? ((INamedTypeSymbol)propertySymbol.Type).TypeArguments[0].Name
                : propertySymbol.Type.Name;

            return typeName switch
            {
                nameof(Guid) => BuildValueParserAndComparerForGuidProperty(propertySymbol, isNullable),
                nameof(DateTime) => BuildValueParserAndComparerForDateTimeProperty(propertySymbol, isNullable),
                nameof(DateTimeOffset) => BuildValueParserAndComparerForDateTimeOffsetProperty(propertySymbol, isNullable),
                nameof(Int32) => BuildValueParserAndComparerForInt32Property(propertySymbol, isNullable),
                nameof(Boolean) => BuildValueParserAndComparerForBooleanProperty(propertySymbol, isNullable),
                nameof(String) => BuildValueParserAndComparerForStringProperty(propertySymbol, isNullable),
                _ => string.Empty,
            };
        }

        private static string BuildValueParserAndComparerForGuidProperty(
            IPropertySymbol propertySymbol,
            bool nullable = false)
        {
            var exceptionContent = !nullable ? "throw new InvalidCastException($\"Can't cast {request.Value} to type {typeof(Guid)})\");" : string.Empty;

            return $$"""
            MemberExpression property = Expression.Property(param, nameof(t1.{{propertySymbol.Name}}));

            if (!Guid.TryParse(request.Value, out var parsedValue))
            {
                {{exceptionContent}}
            }

            comparision = request.FilterOperator switch
            {
                FilterServiceRequest.Operator.Equal => Expression.Equal(property, Expression.Constant(parsedValue)),
                FilterServiceRequest.Operator.NotEqual => Expression.NotEqual(property, Expression.Constant(parsedValue)),
                _ => throw new NotImplementedException(),
            };
            """;
        }

        private static string BuildValueParserAndComparerForDateTimeProperty(
            IPropertySymbol propertySymbol,
            bool nullable = false)
        {
            var exceptionContent = !nullable ? "throw new InvalidCastException($\"Can't cast {request.Value} to type {typeof(DateTime)})\");" : string.Empty;

            return $$"""
            MemberExpression property = Expression.Property(param, nameof(t1.{{propertySymbol.Name}}));

            if (!DateTime.TryParse(request.Value, out var parsedValue))
            {
                {{exceptionContent}}
            }

            comparision = request.FilterOperator switch
            {
                FilterServiceRequest.Operator.Equal => Expression.Equal(property, Expression.Constant(parsedValue)),
                FilterServiceRequest.Operator.NotEqual => Expression.NotEqual(property, Expression.Constant(parsedValue)),
                FilterServiceRequest.Operator.GreaterThan => Expression.GreaterThan(property, Expression.Constant(parsedValue)),
                FilterServiceRequest.Operator.GreaterThanOrEqual => Expression.GreaterThanOrEqual(property, Expression.Constant(parsedValue)),
                FilterServiceRequest.Operator.LessThan => Expression.LessThan(property, Expression.Constant(parsedValue)),
                FilterServiceRequest.Operator.LessThanOrEqual => Expression.LessThanOrEqual(property, Expression.Constant(parsedValue)),
                _ => throw new NotImplementedException(),
            };
            """;
        }

        private static string BuildValueParserAndComparerForDateTimeOffsetProperty(
            IPropertySymbol propertySymbol,
            bool nullable = false)
        {
            var exceptionContent = !nullable ? "throw new InvalidCastException($\"Can't cast {request.Value} to type {typeof(DateTimeOffset)})\");" : string.Empty;

            return $$"""
            MemberExpression property = Expression.Property(param, nameof(t1.{{propertySymbol.Name}}));

            if (!DateTimeOffset.TryParse(request.Value, out var parsedValue))
            {
                {{exceptionContent}}
            }

            comparision = request.FilterOperator switch
            {
                FilterServiceRequest.Operator.Equal => Expression.Equal(property, Expression.Constant(parsedValue)),
                FilterServiceRequest.Operator.NotEqual => Expression.NotEqual(property, Expression.Constant(parsedValue)),
                FilterServiceRequest.Operator.GreaterThan => Expression.GreaterThan(property, Expression.Constant(parsedValue)),
                FilterServiceRequest.Operator.GreaterThanOrEqual => Expression.GreaterThanOrEqual(property, Expression.Constant(parsedValue)),
                FilterServiceRequest.Operator.LessThan => Expression.LessThan(property, Expression.Constant(parsedValue)),
                FilterServiceRequest.Operator.LessThanOrEqual => Expression.LessThanOrEqual(property, Expression.Constant(parsedValue)),
                _ => throw new NotImplementedException(),
            };
            """;
        }

        private static string BuildValueParserAndComparerForInt32Property(
            IPropertySymbol propertySymbol,
            bool nullable = false)
        {
            var exceptionContent = !nullable ? "throw new InvalidCastException($\"Can't cast {request.Value} to type {typeof(Int32)})\");" : string.Empty;

            return $$"""
            MemberExpression property = Expression.Property(param, nameof(t1.{{propertySymbol.Name}}));

            if (!int.TryParse(request.Value, out var parsedValue))
            {
                {{exceptionContent}}
            }

            comparision = request.FilterOperator switch
            {
                FilterServiceRequest.Operator.Equal => Expression.Equal(property, Expression.Constant(parsedValue)),
                FilterServiceRequest.Operator.NotEqual => Expression.NotEqual(property, Expression.Constant(parsedValue)),
                FilterServiceRequest.Operator.GreaterThan => Expression.GreaterThan(property, Expression.Constant(parsedValue)),
                FilterServiceRequest.Operator.GreaterThanOrEqual => Expression.GreaterThanOrEqual(property, Expression.Constant(parsedValue)),
                FilterServiceRequest.Operator.LessThan => Expression.LessThan(property, Expression.Constant(parsedValue)),
                FilterServiceRequest.Operator.LessThanOrEqual => Expression.LessThanOrEqual(property, Expression.Constant(parsedValue)),
                _ => throw new NotImplementedException(),
            };
            """;
        }

        private static string BuildValueParserAndComparerForBooleanProperty(
            IPropertySymbol propertySymbol,
            bool nullable = false)
        {
            var exceptionContent = !nullable ? "throw new InvalidCastException($\"Can't cast {request.Value} to type {typeof(Boolean)})\");" : string.Empty;

            return $$"""
            MemberExpression property = Expression.Property(param, nameof(t1.{{propertySymbol.Name}}));

            if (!bool.TryParse(request.Value, out var parsedValue))
            {
                {{exceptionContent}}
            }

            comparision = request.FilterOperator switch
            {
                FilterServiceRequest.Operator.Equal => Expression.Equal(property, Expression.Constant(parsedValue)),
                FilterServiceRequest.Operator.NotEqual => Expression.NotEqual(property, Expression.Constant(parsedValue)),
                _ => throw new NotImplementedException(),
            };
            """;
        }

        private static string BuildValueParserAndComparerForStringProperty(
            IPropertySymbol propertySymbol,
            bool nullable = false)
        {
            var exceptionContent = !nullable ? "throw new InvalidCastException($\"Can't cast {request.Value} to type {typeof(String)})\");" : string.Empty;

            return $$"""
            MemberExpression property = Expression.Property(param, nameof(t1.{{propertySymbol.Name}}));

            if (request.Value is null)
            {
                {{exceptionContent}}
            }

            var toLowerMethod = typeof(string).GetMethod(nameof(string.ToLower), Type.EmptyTypes)!;
            var containsMethod = typeof(string).GetMethod(nameof(string.Contains), [typeof(string)])!;
            var startsWithMethod = typeof(string).GetMethod(nameof(string.StartsWith), [typeof(string)])!;
            var endsWithMethod = typeof(string).GetMethod(nameof(string.EndsWith), [typeof(string)])!;

            comparision = request.FilterOperator switch
            {
                FilterServiceRequest.Operator.Equal => Expression.Equal(property, Expression.Constant(request.Value)),
                FilterServiceRequest.Operator.NotEqual => Expression.NotEqual(property, Expression.Constant(request.Value)),
                FilterServiceRequest.Operator.Contains => Expression.Call(Expression.Call(property, toLowerMethod), containsMethod, Expression.Call(Expression.Constant(request.Value), toLowerMethod)),
                FilterServiceRequest.Operator.NotContains => Expression.Not(Expression.Call(Expression.Call(property, toLowerMethod), containsMethod, Expression.Call(Expression.Constant(request.Value), toLowerMethod))),
                FilterServiceRequest.Operator.StartWith => Expression.Call(Expression.Call(property, toLowerMethod), startsWithMethod, Expression.Call(Expression.Constant(request.Value), toLowerMethod)),
                FilterServiceRequest.Operator.EndWith => Expression.Call(Expression.Call(property, toLowerMethod), endsWithMethod, Expression.Call(Expression.Constant(request.Value), toLowerMethod)),
                _ => throw new NotImplementedException(),
            };
            """;
        }
    }
}